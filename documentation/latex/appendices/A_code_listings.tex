\appendix

\section{Code Listings and Implementation Details}
\label{app:code-listings}

This appendix provides comprehensive code listings and implementation details for key components of the Robotic Ultrasound System (RUS). The code examples demonstrate best practices in medical robotics software development, including safety-critical programming, real-time constraints, and modular architecture design.

\subsection{Core System Architecture}

\subsubsection{Main System Controller}

\begin{lstlisting}[language=C++, caption={Main System Controller Implementation}, label={lst:app-main-controller}]
/**
 * @file RUSSystemController.h
 * @brief Main system controller for the Robotic Ultrasound System
 * @author RUS Development Team
 * @version 2.1.0
 * @date 2024
 */

#pragma once

#include <memory>
#include <vector>
#include <atomic>
#include <chrono>
#include <thread>
#include <mutex>
#include <condition_variable>

#include "SafetyManager.h"
#include "PathPlanner.h"
#include "UltrasoundController.h"
#include "RobotController.h"
#include "DataLogger.h"
#include "UserInterface.h"

namespace RUS {

class SystemController {
public:
    enum class SystemState {
        OFFLINE,
        INITIALIZING,
        STANDBY,
        CALIBRATING,
        SCANNING,
        EMERGENCY_STOP,
        ERROR,
        MAINTENANCE
    };

    enum class SystemMode {
        MANUAL,
        SEMI_AUTONOMOUS,
        AUTONOMOUS,
        TRAINING
    };

private:
    // Core subsystems
    std::unique_ptr<SafetyManager> safety_manager_;
    std::unique_ptr<PathPlanner> path_planner_;
    std::unique_ptr<UltrasoundController> ultrasound_controller_;
    std::unique_ptr<RobotController> robot_controller_;
    std::unique_ptr<DataLogger> data_logger_;
    std::unique_ptr<UserInterface> user_interface_;

    // System state management
    std::atomic<SystemState> current_state_{SystemState::OFFLINE};
    std::atomic<SystemMode> current_mode_{SystemMode::MANUAL};
    
    // Threading and synchronization
    std::thread main_control_thread_;
    std::thread safety_monitoring_thread_;
    std::thread data_logging_thread_;
    
    std::mutex state_mutex_;
    std::condition_variable state_changed_;
    
    std::atomic<bool> shutdown_requested_{false};
    std::atomic<bool> emergency_stop_active_{false};

    // Performance monitoring
    std::chrono::high_resolution_clock::time_point last_cycle_time_;
    std::atomic<double> cycle_time_ms_{0.0};
    std::atomic<int> missed_deadlines_{0};

    // Configuration
    static constexpr std::chrono::milliseconds CONTROL_CYCLE_TIME{10}; // 100 Hz
    static constexpr std::chrono::milliseconds SAFETY_CHECK_TIME{1};   // 1 kHz
    static constexpr std::chrono::milliseconds LOGGING_CYCLE_TIME{100}; // 10 Hz

public:
    explicit SystemController();
    ~SystemController();

    // Main lifecycle methods
    bool initialize();
    bool start();
    void stop();
    void shutdown();

    // State management
    SystemState getCurrentState() const { return current_state_.load(); }
    SystemMode getCurrentMode() const { return current_mode_.load(); }
    
    bool transitionToState(SystemState new_state);
    bool setSystemMode(SystemMode new_mode);

    // Emergency procedures
    void triggerEmergencyStop(const std::string& reason);
    void resetEmergencyStop();

    // Procedure execution
    bool startProcedure(const ProcedureParameters& params);
    bool pauseProcedure();
    bool resumeProcedure();
    bool stopProcedure();

    // System status
    SystemStatus getSystemStatus() const;
    PerformanceMetrics getPerformanceMetrics() const;
    std::vector<SystemAlert> getActiveAlerts() const;

private:
    // Main control loop
    void mainControlLoop();
    
    // Safety monitoring
    void safetyMonitoringLoop();
    
    // Data logging
    void dataLoggingLoop();

    // State transition validation
    bool isValidStateTransition(SystemState from, SystemState to) const;
    
    // Subsystem coordination
    bool initializeSubsystems();
    bool startSubsystems();
    void stopSubsystems();
    void shutdownSubsystems();

    // Real-time constraints
    void enforceRealTimeConstraints();
    void handleMissedDeadline();

    // Error handling
    void handleSystemError(const SystemError& error);
    void performErrorRecovery();

    // Diagnostics
    bool performSelfDiagnostics();
    void updatePerformanceMetrics();
};

// Implementation

SystemController::SystemController() {
    // Initialize subsystems
    safety_manager_ = std::make_unique<SafetyManager>();
    path_planner_ = std::make_unique<PathPlanner>();
    ultrasound_controller_ = std::make_unique<UltrasoundController>();
    robot_controller_ = std::make_unique<RobotController>();
    data_logger_ = std::make_unique<DataLogger>();
    user_interface_ = std::make_unique<UserInterface>();
}

SystemController::~SystemController() {
    shutdown();
}

bool SystemController::initialize() {
    std::lock_guard<std::mutex> lock(state_mutex_);
    
    if (current_state_ != SystemState::OFFLINE) {
        return false;
    }
    
    current_state_ = SystemState::INITIALIZING;
    
    try {
        // Perform self-diagnostics
        if (!performSelfDiagnostics()) {
            current_state_ = SystemState::ERROR;
            return false;
        }
        
        // Initialize all subsystems
        if (!initializeSubsystems()) {
            current_state_ = SystemState::ERROR;
            return false;
        }
        
        // Setup inter-subsystem communication
        setupSubsystemCommunication();
        
        current_state_ = SystemState::STANDBY;
        state_changed_.notify_all();
        
        return true;
        
    } catch (const std::exception& e) {
        LOG_ERROR("System initialization failed: " + std::string(e.what()));
        current_state_ = SystemState::ERROR;
        return false;
    }
}

bool SystemController::start() {
    std::lock_guard<std::mutex> lock(state_mutex_);
    
    if (current_state_ != SystemState::STANDBY) {
        return false;
    }
    
    try {
        // Start all subsystems
        if (!startSubsystems()) {
            return false;
        }
        
        // Start control threads
        main_control_thread_ = std::thread(&SystemController::mainControlLoop, this);
        safety_monitoring_thread_ = std::thread(&SystemController::safetyMonitoringLoop, this);
        data_logging_thread_ = std::thread(&SystemController::dataLoggingLoop, this);
        
        // Set thread priorities for real-time performance
        setThreadPriority(main_control_thread_, ThreadPriority::HIGH);
        setThreadPriority(safety_monitoring_thread_, ThreadPriority::CRITICAL);
        setThreadPriority(data_logging_thread_, ThreadPriority::LOW);
        
        return true;
        
    } catch (const std::exception& e) {
        LOG_ERROR("System start failed: " + std::string(e.what()));
        current_state_ = SystemState::ERROR;
        return false;
    }
}

void SystemController::mainControlLoop() {
    last_cycle_time_ = std::chrono::high_resolution_clock::now();
    
    while (!shutdown_requested_) {
        auto cycle_start = std::chrono::high_resolution_clock::now();
        
        try {
            // Check for emergency stop
            if (emergency_stop_active_) {
                handleEmergencyStop();
                continue;
            }
            
            // Update system state based on subsystem status
            updateSystemState();
            
            // Execute mode-specific control logic
            switch (current_mode_.load()) {
                case SystemMode::MANUAL:
                    executeManualControl();
                    break;
                case SystemMode::SEMI_AUTONOMOUS:
                    executeSemiAutonomousControl();
                    break;
                case SystemMode::AUTONOMOUS:
                    executeAutonomousControl();
                    break;
                case SystemMode::TRAINING:
                    executeTrainingMode();
                    break;
            }
            
            // Update performance metrics
            updatePerformanceMetrics();
            
        } catch (const std::exception& e) {
            LOG_ERROR("Control loop error: " + std::string(e.what()));
            handleSystemError(SystemError(e.what()));
        }
        
        // Enforce real-time constraints
        enforceRealTimeConstraints();
        
        // Calculate actual cycle time
        auto cycle_end = std::chrono::high_resolution_clock::now();
        auto cycle_duration = std::chrono::duration_cast<std::chrono::microseconds>(
            cycle_end - cycle_start);
        
        cycle_time_ms_ = cycle_duration.count() / 1000.0;
        
        // Sleep for remaining cycle time
        auto sleep_time = CONTROL_CYCLE_TIME - cycle_duration;
        if (sleep_time > std::chrono::microseconds(0)) {
            std::this_thread::sleep_for(sleep_time);
        } else {
            missed_deadlines_++;
            handleMissedDeadline();
        }
        
        last_cycle_time_ = cycle_start;
    }
}

void SystemController::safetyMonitoringLoop() {
    while (!shutdown_requested_) {
        auto safety_check_start = std::chrono::high_resolution_clock::now();
        
        try {
            // Perform comprehensive safety checks
            auto safety_status = safety_manager_->performSafetyCheck();
            
            if (safety_status.has_critical_violation) {
                triggerEmergencyStop("Critical safety violation detected: " + 
                                   safety_status.violation_description);
            }
            
            if (safety_status.has_warning) {
                LOG_WARNING("Safety warning: " + safety_status.warning_description);
                user_interface_->displaySafetyWarning(safety_status.warning_description);
            }
            
        } catch (const std::exception& e) {
            LOG_ERROR("Safety monitoring error: " + std::string(e.what()));
            triggerEmergencyStop("Safety monitoring system failure");
        }
        
        // High-frequency safety monitoring
        auto sleep_time = SAFETY_CHECK_TIME - 
            (std::chrono::high_resolution_clock::now() - safety_check_start);
        
        if (sleep_time > std::chrono::microseconds(0)) {
            std::this_thread::sleep_for(sleep_time);
        }
    }
}

void SystemController::triggerEmergencyStop(const std::string& reason) {
    emergency_stop_active_ = true;
    
    LOG_CRITICAL("EMERGENCY STOP TRIGGERED: " + reason);
    
    // Immediately stop all motion
    robot_controller_->emergencyStop();
    ultrasound_controller_->emergencyStop();
    
    // Transition to emergency stop state
    current_state_ = SystemState::EMERGENCY_STOP;
    
    // Alert all relevant parties
    user_interface_->displayEmergencyAlert(reason);
    data_logger_->logEmergencyEvent(reason);
    
    // Notify external systems
    notifyExternalSystems(EmergencyEvent{reason, std::chrono::system_clock::now()});
}

} // namespace RUS
\end{lstlisting}

\subsubsection{Safety Manager Implementation}

\begin{lstlisting}[language=C++, caption={Safety Manager Core Implementation}, label={lst:app-safety-manager}]
/**
 * @file SafetyManager.h
 * @brief Comprehensive safety management for medical robotics
 * @author RUS Safety Team
 * @version 3.0.0
 * @date 2024
 */

#pragma once

#include <vector>
#include <memory>
#include <atomic>
#include <chrono>
#include <functional>

namespace RUS::Safety {

enum class SafetyLevel {
    SAFE = 0,
    WARNING = 1,
    CAUTION = 2,
    CRITICAL = 3,
    EMERGENCY = 4
};

enum class ViolationType {
    FORCE_LIMIT_EXCEEDED,
    VELOCITY_LIMIT_EXCEEDED,
    WORKSPACE_BOUNDARY_VIOLATED,
    COLLISION_DETECTED,
    SENSOR_MALFUNCTION,
    COMMUNICATION_FAILURE,
    POWER_SYSTEM_FAULT,
    TEMPERATURE_EXCEEDED,
    PATIENT_VITALS_ABNORMAL
};

struct SafetyConstraint {
    std::string name;
    ViolationType type;
    SafetyLevel severity;
    double threshold_value;
    double current_value;
    std::chrono::milliseconds response_time_limit;
    std::function<bool(double)> validation_function;
    std::function<void()> violation_response;
};

struct SafetyStatus {
    SafetyLevel overall_level;
    bool has_critical_violation;
    bool has_warning;
    std::string violation_description;
    std::string warning_description;
    std::vector<SafetyConstraint> active_constraints;
    std::chrono::system_clock::time_point timestamp;
};

class SafetyManager {
private:
    // Safety constraints database
    std::vector<SafetyConstraint> safety_constraints_;
    
    // Monitoring systems
    std::unique_ptr<ForceMonitor> force_monitor_;
    std::unique_ptr<VelocityMonitor> velocity_monitor_;
    std::unique_ptr<WorkspaceMonitor> workspace_monitor_;
    std::unique_ptr<CollisionDetector> collision_detector_;
    std::unique_ptr<SensorMonitor> sensor_monitor_;
    std::unique_ptr<PatientMonitor> patient_monitor_;
    
    // Emergency response systems
    std::vector<std::function<void()>> emergency_responses_;
    
    // Safety state
    std::atomic<SafetyLevel> current_safety_level_{SafetyLevel::SAFE};
    std::atomic<bool> safety_system_enabled_{true};
    
    // Performance monitoring
    std::chrono::high_resolution_clock::time_point last_check_time_;
    std::atomic<int> safety_checks_performed_{0};
    std::atomic<int> violations_detected_{0};

public:
    explicit SafetyManager();
    ~SafetyManager() = default;

    // Initialization and configuration
    bool initialize();
    void configureSafetyConstraints(const std::vector<SafetyConstraint>& constraints);
    void addSafetyConstraint(const SafetyConstraint& constraint);
    void removeSafetyConstraint(const std::string& constraint_name);

    // Main safety checking
    SafetyStatus performSafetyCheck();
    bool validateSafetyConstraints();
    
    // Emergency handling
    void registerEmergencyResponse(std::function<void()> response);
    void triggerEmergencyResponse();
    
    // Force monitoring
    bool checkForceConstraints(const ForceVector& current_forces);
    void setForceLimit(double max_force_newtons);
    
    // Velocity monitoring
    bool checkVelocityConstraints(const VelocityVector& current_velocity);
    void setVelocityLimit(double max_velocity_mm_per_sec);
    
    // Workspace monitoring
    bool checkWorkspaceBoundaries(const Position& current_position);
    void defineWorkspaceBoundaries(const WorkspaceBoundary& boundaries);
    
    // Collision detection
    bool checkCollisionRisk(const RobotState& robot_state);
    void updateCollisionModel(const ObstacleMap& obstacles);
    
    // Patient monitoring integration
    bool checkPatientSafety(const PatientVitals& vitals);
    void setPatientSafetyThresholds(const PatientSafetyProfile& profile);
    
    // System diagnostics
    bool performSelfDiagnostic();
    SafetySystemStatus getSystemStatus() const;
    
    // Configuration and calibration
    void enableSafetySystem() { safety_system_enabled_ = true; }
    void disableSafetySystem() { safety_system_enabled_ = false; }
    bool isSafetySystemEnabled() const { return safety_system_enabled_; }

private:
    // Internal safety checking methods
    bool checkIndividualConstraint(const SafetyConstraint& constraint);
    SafetyLevel calculateOverallSafetyLevel() const;
    void logSafetyViolation(const SafetyConstraint& violated_constraint);
    void executeViolationResponse(const SafetyConstraint& constraint);
    
    // Monitoring system updates
    void updateMonitoringSystems();
    void validateMonitoringSystemHealth();
    
    // Performance tracking
    void updatePerformanceMetrics();
};

// Implementation

SafetyManager::SafetyManager() {
    // Initialize monitoring systems
    force_monitor_ = std::make_unique<ForceMonitor>();
    velocity_monitor_ = std::make_unique<VelocityMonitor>();
    workspace_monitor_ = std::make_unique<WorkspaceMonitor>();
    collision_detector_ = std::make_unique<CollisionDetector>();
    sensor_monitor_ = std::make_unique<SensorMonitor>();
    patient_monitor_ = std::make_unique<PatientMonitor>();
}

bool SafetyManager::initialize() {
    try {
        // Initialize all monitoring systems
        if (!force_monitor_->initialize()) {
            LOG_ERROR("Failed to initialize force monitor");
            return false;
        }
        
        if (!velocity_monitor_->initialize()) {
            LOG_ERROR("Failed to initialize velocity monitor");
            return false;
        }
        
        if (!workspace_monitor_->initialize()) {
            LOG_ERROR("Failed to initialize workspace monitor");
            return false;
        }
        
        if (!collision_detector_->initialize()) {
            LOG_ERROR("Failed to initialize collision detector");
            return false;
        }
        
        // Configure default safety constraints
        configureDefaultSafetyConstraints();
        
        // Perform initial self-diagnostic
        if (!performSelfDiagnostic()) {
            LOG_ERROR("Safety system self-diagnostic failed");
            return false;
        }
        
        LOG_INFO("Safety Manager initialized successfully");
        return true;
        
    } catch (const std::exception& e) {
        LOG_ERROR("Safety Manager initialization failed: " + std::string(e.what()));
        return false;
    }
}

SafetyStatus SafetyManager::performSafetyCheck() {
    auto check_start = std::chrono::high_resolution_clock::now();
    
    SafetyStatus status;
    status.timestamp = std::chrono::system_clock::now();
    status.has_critical_violation = false;
    status.has_warning = false;
    status.overall_level = SafetyLevel::SAFE;
    
    if (!safety_system_enabled_) {
        status.warning_description = "Safety system is disabled";
        status.has_warning = true;
        status.overall_level = SafetyLevel::WARNING;
        return status;
    }
    
    try {
        // Update all monitoring systems
        updateMonitoringSystems();
        
        // Check each safety constraint
        for (const auto& constraint : safety_constraints_) {
            if (!checkIndividualConstraint(constraint)) {
                // Constraint violated
                if (constraint.severity >= SafetyLevel::CRITICAL) {
                    status.has_critical_violation = true;
                    status.violation_description += constraint.name + "; ";
                } else if (constraint.severity >= SafetyLevel::WARNING) {
                    status.has_warning = true;
                    status.warning_description += constraint.name + "; ";
                }
                
                // Execute violation response
                executeViolationResponse(constraint);
                
                // Log violation
                logSafetyViolation(constraint);
                
                violations_detected_++;
            }
        }
        
        // Calculate overall safety level
        status.overall_level = calculateOverallSafetyLevel();
        current_safety_level_ = status.overall_level;
        
        // Copy active constraints
        status.active_constraints = safety_constraints_;
        
    } catch (const std::exception& e) {
        LOG_ERROR("Safety check failed: " + std::string(e.what()));
        status.has_critical_violation = true;
        status.violation_description = "Safety system malfunction: " + std::string(e.what());
        status.overall_level = SafetyLevel::EMERGENCY;
    }
    
    // Update performance metrics
    safety_checks_performed_++;
    updatePerformanceMetrics();
    
    return status;
}

bool SafetyManager::checkForceConstraints(const ForceVector& current_forces) {
    // Check magnitude of force vector
    double force_magnitude = current_forces.magnitude();
    
    for (const auto& constraint : safety_constraints_) {
        if (constraint.type == ViolationType::FORCE_LIMIT_EXCEEDED) {
            if (force_magnitude > constraint.threshold_value) {
                LOG_WARNING("Force limit exceeded: " + 
                          std::to_string(force_magnitude) + "N > " + 
                          std::to_string(constraint.threshold_value) + "N");
                return false;
            }
        }
    }
    
    // Check individual force components
    if (std::abs(current_forces.x) > MAX_FORCE_X ||
        std::abs(current_forces.y) > MAX_FORCE_Y ||
        std::abs(current_forces.z) > MAX_FORCE_Z) {
        return false;
    }
    
    return true;
}

bool SafetyManager::checkVelocityConstraints(const VelocityVector& current_velocity) {
    double velocity_magnitude = current_velocity.magnitude();
    
    for (const auto& constraint : safety_constraints_) {
        if (constraint.type == ViolationType::VELOCITY_LIMIT_EXCEEDED) {
            if (velocity_magnitude > constraint.threshold_value) {
                LOG_WARNING("Velocity limit exceeded: " + 
                          std::to_string(velocity_magnitude) + "mm/s > " + 
                          std::to_string(constraint.threshold_value) + "mm/s");
                return false;
            }
        }
    }
    
    return true;
}

void SafetyManager::configureDefaultSafetyConstraints() {
    // Force constraint
    safety_constraints_.push_back({
        .name = "Maximum Applied Force",
        .type = ViolationType::FORCE_LIMIT_EXCEEDED,
        .severity = SafetyLevel::CRITICAL,
        .threshold_value = 10.0, // 10 Newtons
        .current_value = 0.0,
        .response_time_limit = std::chrono::milliseconds(5),
        .validation_function = [this](double force) { 
            return force <= 10.0; 
        },
        .violation_response = [this]() { 
            triggerEmergencyResponse(); 
        }
    });
    
    // Velocity constraint
    safety_constraints_.push_back({
        .name = "Maximum Velocity",
        .type = ViolationType::VELOCITY_LIMIT_EXCEEDED,
        .severity = SafetyLevel::CRITICAL,
        .threshold_value = 50.0, // 50 mm/s
        .current_value = 0.0,
        .response_time_limit = std::chrono::milliseconds(10),
        .validation_function = [this](double velocity) { 
            return velocity <= 50.0; 
        },
        .violation_response = [this]() { 
            triggerEmergencyResponse(); 
        }
    });
    
    // Workspace boundary constraint
    safety_constraints_.push_back({
        .name = "Workspace Boundaries",
        .type = ViolationType::WORKSPACE_BOUNDARY_VIOLATED,
        .severity = SafetyLevel::CRITICAL,
        .threshold_value = 0.0, // Binary check
        .current_value = 0.0,
        .response_time_limit = std::chrono::milliseconds(1),
        .validation_function = [this](double position) { 
            return workspace_monitor_->isPositionSafe(Position(position)); 
        },
        .violation_response = [this]() { 
            triggerEmergencyResponse(); 
        }
    });
}

} // namespace RUS::Safety
\end{lstlisting}

\subsection{Path Planning Implementation}

\subsubsection{STOMP Algorithm Implementation}

\begin{lstlisting}[language=C++, caption={STOMP Path Planning Algorithm}, label={lst:app-stomp}]
/**
 * @file STOMPPlanner.h
 * @brief Stochastic Trajectory Optimization for Motion Planning
 * @author RUS Planning Team
 * @version 2.5.0
 * @date 2024
 */

#pragma once

#include <eigen3/Eigen/Dense>
#include <vector>
#include <random>
#include <memory>

namespace RUS::Planning {

class STOMPPlanner {
private:
    // Algorithm parameters
    struct STOMPParameters {
        int num_iterations = 100;
        int num_rollouts = 50;
        int trajectory_length = 100;
        double learning_rate = 0.1;
        double exploration_variance = 1.0;
        double smoothing_cost_weight = 1.0;
        double obstacle_cost_weight = 10.0;
        double control_cost_weight = 0.1;
        bool use_importance_sampling = true;
    };
    
    STOMPParameters params_;
    
    // Trajectory representation
    using Trajectory = Eigen::MatrixXd; // [time_steps x dof]
    using CostVector = Eigen::VectorXd;
    
    // Cost function components
    std::unique_ptr<SmoothnessCost> smoothness_cost_;
    std::unique_ptr<ObstacleCost> obstacle_cost_;
    std::unique_ptr<ControlCost> control_cost_;
    
    // Noise generation
    std::random_device rd_;
    std::mt19937 gen_;
    std::normal_distribution<double> noise_dist_;
    
    // Optimization state
    Trajectory nominal_trajectory_;
    std::vector<Trajectory> rollouts_;
    CostVector rollout_costs_;
    
public:
    explicit STOMPPlanner(const STOMPParameters& params = STOMPParameters{});
    ~STOMPPlanner() = default;
    
    // Main planning interface
    bool planTrajectory(const PlanningProblem& problem, 
                       Trajectory& optimized_trajectory);
    
    // Configuration
    void setParameters(const STOMPParameters& params) { params_ = params; }
    STOMPParameters getParameters() const { return params_; }
    
    // Cost function configuration
    void configureSmoothnessWeight(double weight);
    void configureObstacleWeight(double weight);
    void configureControlWeight(double weight);

private:
    // Core STOMP algorithm
    bool initializeTrajectory(const PlanningProblem& problem);
    void generateRollouts();
    void evaluateRollouts(const PlanningProblem& problem);
    void updateTrajectory();
    bool hasConverged() const;
    
    // Noise generation and sampling
    Eigen::MatrixXd generateCorrelatedNoise(int length, int dof);
    void applySmoothingKernel(Eigen::MatrixXd& noise);
    
    // Cost evaluation
    double evaluateTrajectory(const Trajectory& trajectory, 
                             const PlanningProblem& problem);
    double calculateSmoothnessCost(const Trajectory& trajectory);
    double calculateObstacleCost(const Trajectory& trajectory, 
                                const ObstacleMap& obstacles);
    double calculateControlCost(const Trajectory& trajectory);
    
    // Trajectory utilities
    void interpolateTrajectory(const Waypoint& start, 
                              const Waypoint& goal, 
                              Trajectory& trajectory);
    void enforceConstraints(Trajectory& trajectory, 
                           const PlanningConstraints& constraints);
    
    // Importance sampling
    void computeImportanceWeights(CostVector& weights);
    void updateWithImportanceSampling();
};

// Implementation

STOMPPlanner::STOMPPlanner(const STOMPParameters& params) 
    : params_(params), gen_(rd_()), noise_dist_(0.0, 1.0) {
    
    // Initialize cost functions
    smoothness_cost_ = std::make_unique<SmoothnessCost>();
    obstacle_cost_ = std::make_unique<ObstacleCost>();
    control_cost_ = std::make_unique<ControlCost>();
    
    // Pre-allocate rollout storage
    rollouts_.resize(params_.num_rollouts);
    rollout_costs_.resize(params_.num_rollouts);
}

bool STOMPPlanner::planTrajectory(const PlanningProblem& problem, 
                                 Trajectory& optimized_trajectory) {
    
    LOG_INFO("Starting STOMP trajectory optimization");
    auto start_time = std::chrono::high_resolution_clock::now();
    
    try {
        // Initialize nominal trajectory
        if (!initializeTrajectory(problem)) {
            LOG_ERROR("Failed to initialize trajectory");
            return false;
        }
        
        // Main optimization loop
        for (int iteration = 0; iteration < params_.num_iterations; ++iteration) {
            // Generate noisy rollouts
            generateRollouts();
            
            // Evaluate all rollouts
            evaluateRollouts(problem);
            
            // Update nominal trajectory
            updateTrajectory();
            
            // Check convergence
            if (hasConverged()) {
                LOG_INFO("STOMP converged after " + std::to_string(iteration) + 
                        " iterations");
                break;
            }
            
            // Progress logging
            if (iteration % 10 == 0) {
                double best_cost = rollout_costs_.minCoeff();
                LOG_DEBUG("Iteration " + std::to_string(iteration) + 
                         ", best cost: " + std::to_string(best_cost));
            }
        }
        
        // Return optimized trajectory
        optimized_trajectory = nominal_trajectory_;
        
        auto end_time = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
            end_time - start_time);
        
        LOG_INFO("STOMP optimization completed in " + 
                std::to_string(duration.count()) + "ms");
        
        return true;
        
    } catch (const std::exception& e) {
        LOG_ERROR("STOMP planning failed: " + std::string(e.what()));
        return false;
    }
}

void STOMPPlanner::generateRollouts() {
    const int dof = nominal_trajectory_.cols();
    const int length = nominal_trajectory_.rows();
    
    for (int i = 0; i < params_.num_rollouts; ++i) {
        // Generate correlated noise
        Eigen::MatrixXd noise = generateCorrelatedNoise(length, dof);
        
        // Apply exploration variance
        noise *= params_.exploration_variance;
        
        // Create rollout by adding noise to nominal trajectory
        rollouts_[i] = nominal_trajectory_ + noise;
        
        // Ensure rollout starts and ends at desired waypoints
        rollouts_[i].row(0) = nominal_trajectory_.row(0); // Start
        rollouts_[i].row(length - 1) = nominal_trajectory_.row(length - 1); // Goal
    }
}

Eigen::MatrixXd STOMPPlanner::generateCorrelatedNoise(int length, int dof) {
    Eigen::MatrixXd noise(length, dof);
    
    // Generate uncorrelated Gaussian noise
    for (int i = 0; i < length; ++i) {
        for (int j = 0; j < dof; ++j) {
            noise(i, j) = noise_dist_(gen_);
        }
    }
    
    // Apply smoothing kernel for temporal correlation
    applySmoothingKernel(noise);
    
    return noise;
}

void STOMPPlanner::applySmoothingKernel(Eigen::MatrixXd& noise) {
    const int length = noise.rows();
    const int dof = noise.cols();
    
    // Simple 3-point smoothing kernel [0.25, 0.5, 0.25]
    Eigen::MatrixXd smoothed_noise = noise;
    
    for (int j = 0; j < dof; ++j) {
        for (int i = 1; i < length - 1; ++i) {
            smoothed_noise(i, j) = 0.25 * noise(i - 1, j) + 
                                  0.5 * noise(i, j) + 
                                  0.25 * noise(i + 1, j);
        }
    }
    
    noise = smoothed_noise;
}

void STOMPPlanner::evaluateRollouts(const PlanningProblem& problem) {
    // Parallel evaluation of rollouts
    #pragma omp parallel for
    for (int i = 0; i < params_.num_rollouts; ++i) {
        rollout_costs_[i] = evaluateTrajectory(rollouts_[i], problem);
    }
}

double STOMPPlanner::evaluateTrajectory(const Trajectory& trajectory, 
                                       const PlanningProblem& problem) {
    double total_cost = 0.0;
    
    // Smoothness cost
    double smoothness = calculateSmoothnessCost(trajectory);
    total_cost += params_.smoothing_cost_weight * smoothness;
    
    // Obstacle cost
    double obstacle = calculateObstacleCost(trajectory, problem.obstacle_map);
    total_cost += params_.obstacle_cost_weight * obstacle;
    
    // Control cost
    double control = calculateControlCost(trajectory);
    total_cost += params_.control_cost_weight * control;
    
    return total_cost;
}

double STOMPPlanner::calculateSmoothnessCost(const Trajectory& trajectory) {
    const int length = trajectory.rows();
    const int dof = trajectory.cols();
    
    double cost = 0.0;
    
    // Calculate finite difference derivatives
    for (int i = 1; i < length - 1; ++i) {
        for (int j = 0; j < dof; ++j) {
            // Second derivative (acceleration)
            double accel = trajectory(i + 1, j) - 2 * trajectory(i, j) + 
                          trajectory(i - 1, j);
            cost += accel * accel;
        }
    }
    
    return cost;
}

double STOMPPlanner::calculateObstacleCost(const Trajectory& trajectory, 
                                          const ObstacleMap& obstacles) {
    const int length = trajectory.rows();
    double cost = 0.0;
    
    for (int i = 0; i < length; ++i) {
        // Forward kinematics to get end-effector position
        Position ee_position = forwardKinematics(trajectory.row(i));
        
        // Check collision with obstacles
        double clearance = obstacles.getMinimumClearance(ee_position);
        
        if (clearance < SAFETY_MARGIN) {
            // Exponential penalty for proximity to obstacles
            double penalty = std::exp(-clearance / SAFETY_MARGIN);
            cost += penalty;
        }
    }
    
    return cost;
}

void STOMPPlanner::updateTrajectory() {
    if (params_.use_importance_sampling) {
        updateWithImportanceSampling();
    } else {
        // Simple weighted average based on costs
        CostVector weights = (-rollout_costs_).array().exp();
        weights /= weights.sum();
        
        nominal_trajectory_.setZero();
        for (int i = 0; i < params_.num_rollouts; ++i) {
            nominal_trajectory_ += weights[i] * rollouts_[i];
        }
    }
    
    // Apply learning rate
    // trajectory_update = params_.learning_rate * (new_trajectory - nominal_trajectory_)
    // nominal_trajectory_ += trajectory_update
}

void STOMPPlanner::updateWithImportanceSampling() {
    // Compute importance weights
    CostVector importance_weights;
    computeImportanceWeights(importance_weights);
    
    // Update trajectory using importance-weighted rollouts
    Eigen::MatrixXd weighted_sum = Eigen::MatrixXd::Zero(
        nominal_trajectory_.rows(), nominal_trajectory_.cols());
    
    double total_weight = 0.0;
    
    for (int i = 0; i < params_.num_rollouts; ++i) {
        weighted_sum += importance_weights[i] * rollouts_[i];
        total_weight += importance_weights[i];
    }
    
    if (total_weight > 1e-8) {
        Eigen::MatrixXd new_trajectory = weighted_sum / total_weight;
        
        // Apply learning rate
        nominal_trajectory_ = (1.0 - params_.learning_rate) * nominal_trajectory_ + 
                             params_.learning_rate * new_trajectory;
    }
}

bool STOMPPlanner::hasConverged() const {
    // Check if cost improvement is below threshold
    if (rollout_costs_.size() < 2) return false;
    
    double current_best = rollout_costs_.minCoeff();
    double cost_variance = 0.0;
    
    for (int i = 0; i < rollout_costs_.size(); ++i) {
        double diff = rollout_costs_[i] - current_best;
        cost_variance += diff * diff;
    }
    
    cost_variance /= rollout_costs_.size();
    
    // Converged if variance is low
    return cost_variance < 1e-6;
}

} // namespace RUS::Planning
\end{lstlisting}

\subsection{Real-Time Control Implementation}

\subsubsection{Robot Controller with Real-Time Constraints}

\begin{lstlisting}[language=C++, caption={Real-Time Robot Controller}, label={lst:app-realtime-controller}]
/**
 * @file RealTimeRobotController.h
 * @brief Real-time robot control with deterministic timing
 * @author RUS Control Team
 * @version 1.8.0
 * @date 2024
 */

#pragma once

#include <chrono>
#include <thread>
#include <atomic>
#include <memory>
#include <queue>
#include <mutex>

#include <xenomai/cobalt.h>  // Real-time kernel support
#include <eigen3/Eigen/Dense>

namespace RUS::Control {

class RealTimeRobotController {
private:
    // Real-time parameters
    static constexpr std::chrono::nanoseconds CONTROL_PERIOD{1000000}; // 1 kHz
    static constexpr int RT_PRIORITY = 80;
    static constexpr int RT_STACK_SIZE = 64 * 1024;
    
    // Control state
    enum class ControlMode {
        POSITION_CONTROL,
        VELOCITY_CONTROL,
        FORCE_CONTROL,
        IMPEDANCE_CONTROL,
        EMERGENCY_STOP
    };
    
    struct RobotState {
        Eigen::VectorXd joint_positions;
        Eigen::VectorXd joint_velocities;
        Eigen::VectorXd joint_torques;
        Eigen::Vector3d end_effector_position;
        Eigen::Quaterniond end_effector_orientation;
        Eigen::Vector3d end_effector_force;
        std::chrono::high_resolution_clock::time_point timestamp;
    };
    
    struct ControlCommand {
        ControlMode mode;
        Eigen::VectorXd target_positions;
        Eigen::VectorXd target_velocities;
        Eigen::Vector3d target_force;
        Eigen::Matrix3d impedance_stiffness;
        Eigen::Matrix3d impedance_damping;
        bool emergency_stop;
        std::chrono::high_resolution_clock::time_point timestamp;
    };
    
    // Hardware interfaces
    std::unique_ptr<HardwareInterface> hardware_interface_;
    std::unique_ptr<JointController> joint_controller_;
    std::unique_ptr<ForceController> force_controller_;
    std::unique_ptr<SafetyMonitor> safety_monitor_;
    
    // Real-time thread management
    pthread_t rt_thread_;
    std::atomic<bool> rt_thread_running_{false};
    std::atomic<bool> shutdown_requested_{false};
    
    // Thread-safe command queue
    std::queue<ControlCommand> command_queue_;
    mutable std::mutex command_mutex_;
    
    // Current state
    std::atomic<ControlMode> current_mode_{ControlMode::POSITION_CONTROL};
    RobotState current_state_;
    ControlCommand current_command_;
    
    // Performance monitoring
    std::atomic<uint64_t> control_cycles_{0};
    std::atomic<uint64_t> missed_deadlines_{0};
    std::atomic<double> max_cycle_time_us_{0.0};
    std::atomic<double> avg_cycle_time_us_{0.0};
    
    // Control algorithms
    std::unique_ptr<PIDController> position_controllers_;
    std::unique_ptr<AdmittanceController> force_controller_impl_;
    std::unique_ptr<ImpedanceController> impedance_controller_;

public:
    explicit RealTimeRobotController();
    ~RealTimeRobotController();
    
    // Lifecycle management
    bool initialize();
    bool start();
    void stop();
    void shutdown();
    
    // Command interface
    bool sendPositionCommand(const Eigen::VectorXd& target_positions);
    bool sendVelocityCommand(const Eigen::VectorXd& target_velocities);
    bool sendForceCommand(const Eigen::Vector3d& target_force);
    bool sendImpedanceCommand(const Eigen::Matrix3d& stiffness, 
                             const Eigen::Matrix3d& damping);
    
    void emergencyStop();
    void resetEmergencyStop();
    
    // State query
    RobotState getCurrentState() const;
    ControlMode getCurrentMode() const { return current_mode_.load(); }
    bool isOperational() const;
    
    // Performance monitoring
    struct PerformanceMetrics {
        uint64_t total_cycles;
        uint64_t missed_deadlines;
        double deadline_miss_rate;
        double max_cycle_time_us;
        double avg_cycle_time_us;
        double cpu_utilization;
    };
    
    PerformanceMetrics getPerformanceMetrics() const;

private:
    // Real-time control loop
    static void* rtControlLoop(void* arg);
    void executeControlCycle();
    
    // Control mode implementations
    void executePositionControl();
    void executeVelocityControl();
    void executeForceControl();
    void executeImpedanceControl();
    void executeEmergencyStop();
    
    // Hardware interaction
    bool readSensorData();
    bool sendMotorCommands(const Eigen::VectorXd& commands);
    
    // Real-time utilities
    bool setupRealTimeThread();
    void enforceRealTimeConstraints();
    void updatePerformanceMetrics(std::chrono::nanoseconds cycle_time);
    
    // Safety and validation
    bool validateCommand(const ControlCommand& command);
    bool checkSafetyConstraints();
    void handleSafetyViolation();
    
    // Command processing
    bool getNextCommand(ControlCommand& command);
    void processCommandQueue();
};

// Implementation

RealTimeRobotController::RealTimeRobotController() {
    // Initialize hardware interfaces
    hardware_interface_ = std::make_unique<HardwareInterface>();
    joint_controller_ = std::make_unique<JointController>(6); // 6-DOF robot
    force_controller_ = std::make_unique<ForceController>();
    safety_monitor_ = std::make_unique<SafetyMonitor>();
    
    // Initialize control algorithms
    position_controllers_ = std::make_unique<PIDController>(6);
    force_controller_impl_ = std::make_unique<AdmittanceController>();
    impedance_controller_ = std::make_unique<ImpedanceController>();
    
    // Initialize state
    current_state_.joint_positions = Eigen::VectorXd::Zero(6);
    current_state_.joint_velocities = Eigen::VectorXd::Zero(6);
    current_state_.joint_torques = Eigen::VectorXd::Zero(6);
}

RealTimeRobotController::~RealTimeRobotController() {
    shutdown();
}

bool RealTimeRobotController::initialize() {
    try {
        // Initialize hardware interface
        if (!hardware_interface_->initialize()) {
            LOG_ERROR("Failed to initialize hardware interface");
            return false;
        }
        
        // Configure control algorithms
        position_controllers_->configureGains(
            Eigen::VectorXd::Constant(6, 1000.0), // Kp
            Eigen::VectorXd::Constant(6, 50.0),   // Ki
            Eigen::VectorXd::Constant(6, 10.0)    // Kd
        );
        
        force_controller_impl_->configureParameters(
            10.0,  // Mass
            100.0, // Damping
            1000.0 // Stiffness
        );
        
        // Perform initial state reading
        if (!readSensorData()) {
            LOG_ERROR("Failed to read initial sensor data");
            return false;
        }
        
        LOG_INFO("Real-time robot controller initialized successfully");
        return true;
        
    } catch (const std::exception& e) {
        LOG_ERROR("Controller initialization failed: " + std::string(e.what()));
        return false;
    }
}

bool RealTimeRobotController::start() {
    if (rt_thread_running_) {
        LOG_WARNING("Real-time thread already running");
        return true;
    }
    
    // Setup real-time thread
    if (!setupRealTimeThread()) {
        LOG_ERROR("Failed to setup real-time thread");
        return false;
    }
    
    rt_thread_running_ = true;
    
    // Create real-time thread
    pthread_attr_t attr;
    struct sched_param param;
    
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
    pthread_attr_setstacksize(&attr, RT_STACK_SIZE);
    pthread_attr_setschedpolicy(&attr, SCHED_FIFO);
    
    param.sched_priority = RT_PRIORITY;
    pthread_attr_setschedparam(&attr, &param);
    
    int result = pthread_create(&rt_thread_, &attr, rtControlLoop, this);
    pthread_attr_destroy(&attr);
    
    if (result != 0) {
        LOG_ERROR("Failed to create real-time thread: " + std::to_string(result));
        rt_thread_running_ = false;
        return false;
    }
    
    LOG_INFO("Real-time robot controller started successfully");
    return true;
}

void* RealTimeRobotController::rtControlLoop(void* arg) {
    RealTimeRobotController* controller = 
        static_cast<RealTimeRobotController*>(arg);
    
    // Set thread name for debugging
    pthread_setname_np(pthread_self(), "RUS_RT_Control");
    
    // Lock memory to prevent page faults
    mlockall(MCL_CURRENT | MCL_FUTURE);
    
    auto next_cycle = std::chrono::high_resolution_clock::now();
    
    while (controller->rt_thread_running_ && !controller->shutdown_requested_) {
        auto cycle_start = std::chrono::high_resolution_clock::now();
        
        try {
            // Execute control cycle
            controller->executeControlCycle();
            
        } catch (const std::exception& e) {
            LOG_ERROR("Real-time control cycle error: " + std::string(e.what()));
            controller->handleSafetyViolation();
        }
        
        // Calculate cycle time
        auto cycle_end = std::chrono::high_resolution_clock::now();
        auto cycle_time = cycle_end - cycle_start;
        
        controller->updatePerformanceMetrics(cycle_time);
        
        // Wait for next cycle
        next_cycle += CONTROL_PERIOD;
        
        if (cycle_end > next_cycle) {
            // Missed deadline
            controller->missed_deadlines_++;
            next_cycle = cycle_end; // Reset timing
        } else {
            std::this_thread::sleep_until(next_cycle);
        }
        
        controller->control_cycles_++;
    }
    
    // Unlock memory
    munlockall();
    
    LOG_INFO("Real-time control loop terminated");
    return nullptr;
}

void RealTimeRobotController::executeControlCycle() {
    // Read current sensor data
    if (!readSensorData()) {
        LOG_ERROR("Failed to read sensor data in control cycle");
        handleSafetyViolation();
        return;
    }
    
    // Process command queue
    processCommandQueue();
    
    // Check safety constraints
    if (!checkSafetyConstraints()) {
        current_mode_ = ControlMode::EMERGENCY_STOP;
        handleSafetyViolation();
        return;
    }
    
    // Execute control based on current mode
    switch (current_mode_.load()) {
        case ControlMode::POSITION_CONTROL:
            executePositionControl();
            break;
            
        case ControlMode::VELOCITY_CONTROL:
            executeVelocityControl();
            break;
            
        case ControlMode::FORCE_CONTROL:
            executeForceControl();
            break;
            
        case ControlMode::IMPEDANCE_CONTROL:
            executeImpedanceControl();
            break;
            
        case ControlMode::EMERGENCY_STOP:
            executeEmergencyStop();
            break;
    }
}

void RealTimeRobotController::executePositionControl() {
    // Get target positions from current command
    const auto& target_positions = current_command_.target_positions;
    
    // Calculate position error
    Eigen::VectorXd position_error = target_positions - current_state_.joint_positions;
    
    // Calculate control output using PID controllers
    Eigen::VectorXd control_output = position_controllers_->computeControl(
        position_error, current_state_.joint_velocities);
    
    // Apply joint limits and safety constraints
    for (int i = 0; i < control_output.size(); ++i) {
        control_output[i] = std::clamp(control_output[i], 
                                     JOINT_TORQUE_LIMITS[i].min, 
                                     JOINT_TORQUE_LIMITS[i].max);
    }
    
    // Send commands to motors
    if (!sendMotorCommands(control_output)) {
        LOG_ERROR("Failed to send motor commands");
        handleSafetyViolation();
    }
}

void RealTimeRobotController::executeForceControl() {
    // Get target force from current command
    const auto& target_force = current_command_.target_force;
    
    // Read current force sensor data
    Eigen::Vector3d current_force = current_state_.end_effector_force;
    
    // Calculate force error
    Eigen::Vector3d force_error = target_force - current_force;
    
    // Compute admittance control
    Eigen::Vector3d velocity_command = 
        force_controller_impl_->computeVelocityCommand(force_error);
    
    // Convert Cartesian velocity to joint velocities (Jacobian inverse)
    Eigen::MatrixXd jacobian = computeJacobian(current_state_.joint_positions);
    Eigen::VectorXd joint_velocities = jacobian.transpose() * velocity_command;
    
    // Convert to joint torques
    Eigen::VectorXd torque_commands = computeInverseDynamics(
        current_state_.joint_positions, joint_velocities);
    
    // Send commands to motors
    if (!sendMotorCommands(torque_commands)) {
        LOG_ERROR("Failed to send motor commands in force control");
        handleSafetyViolation();
    }
}

bool RealTimeRobotController::sendPositionCommand(
    const Eigen::VectorXd& target_positions) {
    
    if (target_positions.size() != 6) {
        LOG_ERROR("Invalid target position vector size");
        return false;
    }
    
    ControlCommand command;
    command.mode = ControlMode::POSITION_CONTROL;
    command.target_positions = target_positions;
    command.timestamp = std::chrono::high_resolution_clock::now();
    command.emergency_stop = false;
    
    if (!validateCommand(command)) {
        LOG_ERROR("Position command validation failed");
        return false;
    }
    
    // Add to command queue
    {
        std::lock_guard<std::mutex> lock(command_mutex_);
        command_queue_.push(command);
    }
    
    return true;
}

void RealTimeRobotController::emergencyStop() {
    LOG_CRITICAL("Emergency stop triggered in robot controller");
    
    // Immediately stop all motors
    hardware_interface_->emergencyStopAllMotors();
    
    // Set emergency stop mode
    current_mode_ = ControlMode::EMERGENCY_STOP;
    
    // Clear command queue
    {
        std::lock_guard<std::mutex> lock(command_mutex_);
        while (!command_queue_.empty()) {
            command_queue_.pop();
        }
    }
    
    // Create emergency stop command
    ControlCommand emergency_command;
    emergency_command.mode = ControlMode::EMERGENCY_STOP;
    emergency_command.emergency_stop = true;
    emergency_command.timestamp = std::chrono::high_resolution_clock::now();
    
    current_command_ = emergency_command;
}

RealTimeRobotController::PerformanceMetrics 
RealTimeRobotController::getPerformanceMetrics() const {
    
    PerformanceMetrics metrics;
    metrics.total_cycles = control_cycles_.load();
    metrics.missed_deadlines = missed_deadlines_.load();
    
    if (metrics.total_cycles > 0) {
        metrics.deadline_miss_rate = 
            static_cast<double>(metrics.missed_deadlines) / metrics.total_cycles;
    } else {
        metrics.deadline_miss_rate = 0.0;
    }
    
    metrics.max_cycle_time_us = max_cycle_time_us_.load();
    metrics.avg_cycle_time_us = avg_cycle_time_us_.load();
    
    // Calculate CPU utilization
    double control_period_us = 
        std::chrono::duration_cast<std::chrono::microseconds>(CONTROL_PERIOD).count();
    metrics.cpu_utilization = metrics.avg_cycle_time_us / control_period_us;
    
    return metrics;
}

} // namespace RUS::Control
\end{lstlisting}

This appendix provides detailed implementation examples of the core system components, demonstrating the sophisticated software architecture, real-time constraints, safety systems, and advanced algorithms that make the RUS system a state-of-the-art medical robotics platform.
